#!/usr/bin/env zsh

COMMAND=${0:t}

init_variables() {
  PACKAGE_NAME=
}


usage() {
  cat << EOF
usage: ${COMMAND} [<options>] package

Display a diff of a package modified files

Options:
  -h,  --help    show this message only
EOF
}


error() {
  [[ -z "$1" ]] || echo "${COMMAND}: $1" >&2
  echo "Try '${COMMAND} --help' for more information." >&2
  exit 1
}


diff_package() {
  local package_version=$(
    pacman --query "${PACKAGE_NAME}" 2> /dev/null \
      | cut --field 2 --delimiter ' '
  )

  # need double --check argument to show modified files
  local package_modified_files=( $(
    pacman --query --check --check "${PACKAGE_NAME}" \
      | grep '^backup file:' \
      | cut --field 4 --delimiter ' ' \
      | uniq
  ) )

  # #OPTIMIZE: if it happens we have packages with many modified files
  # we maybe better extract first a single time instead of doing for each file
  local package_modified_file
  for package_modified_file in ${package_modified_files}; do
    echo "${package_modified_file}"
    tar --extract --to-stdout \
      --file /var/cache/pacman/pkg/${PACKAGE_NAME}-${package_version}-*.pkg.tar.xz \
      "${package_modified_file/\//}" \
      2> /dev/null \
    | diff - "${package_modified_file}"
    echo
  done
}


parse_options() {
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      -h|--help)
        usage
        exit 0
        ;;
      *)
        break 2
        ;;
    esac
  done

  PACKAGE_NAME="$1"
}


validate_options() {
  if [[ -z "${PACKAGE_NAME}" ]]; then
    error 'missing package name'
  fi

  if ! pacman --query "${PACKAGE_NAME}" &> /dev/null; then
    error "invalid package name ${PACKAGE_NAME}"
  fi
}


init_variables
parse_options "$@"
validate_options

diff_package
