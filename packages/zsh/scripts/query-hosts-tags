#!/bin/sh

init_variables() {
  COMMAND=${0##*/}

  # HOSTS_TAGS_FILE is expected to have a YAML structure
  # similar to the following example
  #
  # frontend.example.com:
  #   project: website
  #   environment: test
  # backend.example.com:
  #   project: website
  #   environment: test
  #   purpose: backend
  # database.example.com: [invalid data]
  #
  # there is no restriction on the tags key
  # hosts don't have to have all the same tags
  HOSTS_TAGS_FILE="${XDG_CACHE_HOME:-$HOME/.cache}/hosts_tags.yaml"

  AWK_SCRIPT=
  QUERY_TYPE=hosts
  QUERY_ARGUMENTS=
}

usage() {
  cat <<- EOF
	usage: ${COMMAND} [<options>] [ tags <host> | hosts [<tag>=<value> ...] ]

	Query the hosts tags file

	A "tags" query displays the tags from the host argument
	A "hosts" query displays the hosts matching the tags arguments
	Without any argument, it displays all the hosts

	Options:
	  -h      show this message only
	EOF
}

error() {
  [ -z "$1" ] || echo "${COMMAND}: $1"
  printf "Try '%s -h' for more information.\n" "${COMMAND}"
  exit 1
} >&2

query_tags() {
  AWK_SCRIPT="\$1 == \"$1\""
  AWK_SCRIPT="${AWK_SCRIPT} { for (i=2; i<=NF; i++) print \$i }"

  process_file \
    | column -t -s= -R1
}

query_hosts() {
  AWK_SCRIPT='function any_tag_field_match_string(string)
              {
                for (i=2; i<=NF; i++)
                  if ($i == string) return 1
                return 0
              }
              1'
  while [ "$#" -gt 0 ]; do
    AWK_SCRIPT="${AWK_SCRIPT} && any_tag_field_match_string(\"$1\")"
    shift
  done
  AWK_SCRIPT="${AWK_SCRIPT} { print \$1 }"

  process_file
}

process_file() {
  # transform the YAML structure into multiline records
  # before awk processing
  #
  # frontend.example.com
  # project=website
  # environment=test
  #
  # backend.example.com
  # project=website
  # environment=test
  # purpose=backend

  sed \
    -e 's/^\([^ ][^:]*\):.*$/\n\1/' \
    -e 's/^  //' \
    -e 's/: /=/' \
    "${HOSTS_TAGS_FILE}" \
    | awk \
      "BEGIN { FS=\"\n\"; RS=\"\" } ${AWK_SCRIPT}" \
    | sort
}

parse_options() {
  while getopts h OPT; do
    case "${OPT}" in
      h) usage; exit 0 ;;
      ?) error ;;
    esac
  done

  shift $(( OPTIND - 1 ))

  if [ -n "$1" ]; then
    QUERY_TYPE="$1"
    shift
    QUERY_ARGUMENTS=$*
  fi
}

validate_options() {
  if [ "${QUERY_TYPE}" != 'tags' ] && [ "${QUERY_TYPE}" != 'hosts' ]; then
    error "invalid query type ${QUERY_TYPE}"
  fi

  if [ "${QUERY_TYPE}" = 'tags' ] && [ -z "${QUERY_ARGUMENTS}" ]; then
    error 'missing host argument'
  fi

  if [ "${QUERY_TYPE}" = 'hosts' ]; then
    for QUERY_ARG in ${QUERY_ARGUMENTS}; do
      case "${QUERY_ARG}" in
        ?*=?*) continue ;;
        *) error "invalid tag value argument '${QUERY_ARG}'";;
      esac
    done
  fi
}

init_variables
parse_options "$@"
validate_options

"query_${QUERY_TYPE}" ${QUERY_ARGUMENTS}
