#!/bin/sh

init_variables() {
  COMMAND=${0##*/}

  # HOSTS_TAGS_FILE is expected to have a YAML structure
  # similar to the following example
  #
  # frontend.example.com:
  #   project: website
  #   environment: test
  # backend.example.com:
  #   project: website
  #   environment: test
  #   purpose: backend
  # database.example.com: [invalid data]
  #
  # there is no restriction on the tags key
  # hosts don't have to have all the same tags
  HOSTS_TAGS_FILE="${XDG_CACHE_HOME:-$HOME/.cache}/hosts_tags.yaml"

  AWK_SCRIPT=
  QUERY_TYPE=hosts
  QUERY_ARGUMENTS=
}

error() {
  [ -z "$1" ] || echo "${COMMAND}: $1"
  exit 1
} >&2

query_tags() {
  AWK_SCRIPT="\$1 == \"$1\""
  AWK_SCRIPT="${AWK_SCRIPT} { for (i=2; i<=NF; i++) print \$i }"

  TAGS_VALUES=$( process_file )

  MAX_TAG_LENGTH=$(
    echo "${TAGS_VALUES}" \
      | awk 'BEGIN { FS="=" }
             { if (length($1) > max) { max = length($1) } }
             END { print max }'
  )

  echo "${TAGS_VALUES}" \
    | sed 's/=/\t/' \
    | expand -t "$(( MAX_TAG_LENGTH + 2 ))"
}

query_hosts() {
  AWK_SCRIPT='function any_tag_field_match_string(string)
              {
                for (i=2; i<=NF; i++)
                  if ($i == string) return 1
                return 0
              }
              1'
  while [ "$#" -gt 0 ]; do
    AWK_SCRIPT="${AWK_SCRIPT} && any_tag_field_match_string(\"$1\")"
    shift
  done
  AWK_SCRIPT="${AWK_SCRIPT} { print \$1 }"

  process_file
}

process_file() {
  # transform the YAML structure into multiline records
  # before awk processing
  #
  # frontend.example.com
  # project=website
  # environment=test
  #
  # backend.example.com
  # project=website
  # environment=test
  # purpose=backend

  sed \
    -e 's/^\([^ ][^:]*\):.*$/\n\1/' \
    -e 's/^  //' \
    -e 's/: /=/' \
    "${HOSTS_TAGS_FILE}" \
    | awk \
      "BEGIN { FS=\"\n\"; RS=\"\" } ${AWK_SCRIPT}" \
    | sort
}

parse_options() {
  if [ -n "$1" ]; then
    QUERY_TYPE="$1"
    shift
    QUERY_ARGUMENTS=$*
  fi
}

validate_options() {
  if [ "${QUERY_TYPE}" != 'tags' ] && [ "${QUERY_TYPE}" != 'hosts' ]; then
    error "invalid query type ${QUERY_TYPE}"
  fi

  if [ "${QUERY_TYPE}" = 'tags' ] && [ -z "${QUERY_ARGUMENTS}" ]; then
    error 'missing host argument'
  fi

  if [ "${QUERY_TYPE}" = 'hosts' ]; then
    for QUERY_ARG in ${QUERY_ARGUMENTS}; do
      case "${QUERY_ARG}" in
        ?*=?*) continue ;;
        *) error "invalid tag value argument '${QUERY_ARG}'";;
      esac
    done
  fi
}

init_variables
parse_options "$@"
validate_options

"query_${QUERY_TYPE}" ${QUERY_ARGUMENTS}
