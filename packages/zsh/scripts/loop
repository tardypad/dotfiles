#!/bin/sh

init_variables() {
  COMMAND=${0##*/}

  RUN_COMMAND=
  COUNT=
  INTERVAL=0
  TIME=
}

usage() {
  cat <<- EOF
	usage: ${COMMAND} [<options>] command

	Execute a command in a loop

	Options:
	  -c  COUNT      stops after COUNT runs of the command
	  -h             show this message only
	  -i  INTERVAL   wait INTERVAL seconds between each command run
	                 default is 0, floating number are accepted
	  -t  TIME       stops command runs after a TIME seconds period
	EOF
}

error() {
  [ -z "$1" ] || echo "${COMMAND}: $1"
  echo "Try '${COMMAND} -h' for more information."
  exit 1
} >&2

current_time_sec() {
  # values with leading 0 are interpreted as octals
  # which leads to issue with "08" and "09"
  CUR_HOURS=$( date +%H )
  CUR_MINUTES=$( date +%M )
  CUR_SECONDS=$( date +%S )
  echo $((
    ${CUR_HOURS#0} * 3600 + ${CUR_MINUTES#0} * 60 + ${CUR_SECONDS#0}
  ))
}

loop_command() {
    [ -n "${TIME}" ] && END_TIME=$(( $( current_time_sec ) + TIME ))

    RUN_COUNT=0

    while true; do
      eval "${RUN_COMMAND}"

      RUN_COUNT=$(( RUN_COUNT + 1 ))

      [ -n "${TIME}" ] && [ "$( current_time_sec )" -ge "${END_TIME}" ] && return 0
      [ -n "${COUNT}" ] && [ "${RUN_COUNT}" -ge "${COUNT}" ] && return 0

      sleep "${INTERVAL}"
    done
}

parse_options() {
  while getopts c:hi:t: OPT; do
    case "${OPT}" in
      c) COUNT="${OPTARG}" ;;
      h) usage; exit 0 ;;
      i) INTERVAL="${OPTARG}" ;;
      t) TIME="${OPTARG}" ;;
      ?) error ;;
    esac
  done

  shift $(( OPTIND - 1 ))

  RUN_COMMAND="$*"
}

validate_options() {
  if [ -z "${COUNT}" ] && [ -z "${TIME}" ]; then
    error 'you must specify at least -c or -t options'
  fi

  case "${COUNT}" in
    *[!0-9]*) error 'count must be an integer' ;;
  esac

  case "${TIME}" in
    *[!0-9]*) error 'time must be an integer' ;;
  esac

  case "${INTERVAL}" in
    *[!0-9.]*) error 'interval must be an number' ;;
  esac

  if [ -z "${RUN_COMMAND}" ]; then
    error 'no command to run'
  fi
}

init_variables
parse_options "$@"
validate_options

loop_command
