#!/bin/sh

# "heavily inspired" by Gary Bernhardt's dotfiles script
# https://github.com/garybernhardt/dotfiles/blob/master/bin/run-command-on-git-revisions

init_variables() {
  COMMAND=${0##*/}
  GIT_COMMAND=${COMMAND#*-}

  INITIAL_REF=
  START_REF=
  END_REF=
  RUN_COMMAND=
  QUIET=0
}

usage() {
  cat <<- EOF
	usage: git ${GIT_COMMAND} [<options>] start_ref end_ref command

	Execute a command over a range of git revisions

	Options:
	    -h      show this message only
	    -q      only show command outputs
	EOF
}

error() {
  [ -z "$1" ] || echo "${COMMAND}: $1"
  echo "Try 'git ${GIT_COMMAND} -h' for more information."
  exit 1
} >&2

abort_if_dirty_repo() {
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    error 'not in a git repository'
  fi

  if ! git diff-index --quiet --cached HEAD; then
    error 'you have staged but not committed changes that would be lost'
  fi

  if ! git diff-files --quiet; then
    error 'you have unstaged changes that would be lost'
  fi

  UNTRACKED=$( git ls-files --exclude-standard --others )
  if [ -n "${UNTRACKED}" ]; then
    error 'you have untracked files that could be overwritten'
  fi
}

save_initial_ref() {
  if git symbolic-ref HEAD > /dev/null 2>&1; then
    INITIAL_REF=$( git symbolic-ref --short HEAD )
  else
    INITIAL_REF=$( git rev-parse HEAD )
  fi
}

restore_initial_ref() {
  git checkout -q "${INITIAL_REF}"
}

run_command_over_range() {
  for REVISION in $( git rev-list --reverse ${START_REF}..${END_REF} ); do
    [ "${QUIET}" -eq 0 ] && echo "Checking out: $( git log --oneline -1 "${REVISION}" )"
    git checkout -q "${REVISION}"
    eval "${RUN_COMMAND}"
    git reset --hard -q
  done
}

parse_options() {
  while getopts hq OPT; do
    case "${OPT}" in
      h) usage; exit 0 ;;
      q) QUIET=1 ;;
      ?) error ;;
    esac
  done

  shift $(( OPTIND - 1 ))

  START_REF="$1"
  END_REF="$2"
  shift 2 > /dev/null
  RUN_COMMAND="$*"
}

validate_options() {
  if [ -z "${START_REF}" ]; then
    error 'no start revision'
  fi

  if [ -z "${END_REF}" ]; then
    error 'no end revision'
  fi

  if [ -z "${RUN_COMMAND}" ]; then
    error 'no command to run'
  fi
}

init_variables
parse_options "$@"
validate_options

abort_if_dirty_repo
save_initial_ref
run_command_over_range
restore_initial_ref
