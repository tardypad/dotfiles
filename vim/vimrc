" VIM Configuration
set nocompatible          " Cancel the compatibility with Vi

" Define the plugins
source ~/.vim/plugins.vim

" Disable arrow keys usage to break bad habits
noremap <Up> <nop>
noremap <Down> <nop>
noremap <Left> <nop>
noremap <Right> <nop>
noremap <PageUp> <nop>
noremap <PageDown> <nop>
noremap <Home> <nop>
noremap <End> <nop>

inoremap <Up> <nop>
inoremap <Down> <nop>
inoremap <Left> <nop>
inoremap <Right> <nop>
inoremap <PageUp> <nop>
inoremap <PageDown> <nop>
inoremap <Home> <nop>
inoremap <End> <nop>

vnoremap <Up> <nop>
vnoremap <Down> <nop>
vnoremap <Left> <nop>
vnoremap <Right> <nop>
vnoremap <PageUp> <nop>
vnoremap <PageDown> <nop>
vnoremap <Home> <nop>
vnoremap <End> <nop>

" Use space as leader
let mapleader = "\<Space>"

" Disable space moves cursor in non editing mode
noremap <Space> <nop>
vnoremap <Space> <nop>

" disable usage of Ctrl-J as Enter in command mode
cnoremap <C-J> <nop>

" remove ex mode binding
nmap Q <nop>

" Activate syntax coloring
syntax enable

" Show keys typed in status line
set showcmd

" Do not show mode in last line
" since already present in status line
set noshowmode

" -- Display
set title                 " Update the title of your window or your terminal
set relativenumber        " Display relative line numbers
set ruler                 " Display cursor position
set nowrap                " Don't wrap lines when they are too long
set sidescroll=10         " horizontal scroll of columns
set cursorline            " highlight the current line
set scrolloff=3           " Display at least 3 lines around you cursor
                          " (for scrolling)

" -- Beep
set novisualbell          " Prevent Vim from beeping
set noerrorbells          " Prevent Vim from beeping

" Backspace behaves as expected
set backspace=indent,eol,start

" -- Tabs
set tabstop=4       " number of visual spaces per tab
set softtabstop=4   " number of spaces in tab when editing
set expandtab       " tabs are spaces when editing
set shiftwidth=4    " size of an indentation
set smarttab        " tab makes cursor goes to next indent when editing new line

" Visual autocomplete for command menu
set wildmenu

" Define files to ignore in globbing / expanding / ...
set wildignore+=*~,*.swp

" automatically reload file when modified outside of vim
" and not modified locally
set autoread

" Hide buffer (file) instead of abandoning when switching
" to another buffer
set hidden

" Activate specific behavior per file type such as syntax and indentation
filetype on
filetype plugin on
filetype indent on

" Decrease silent time before swap file gets written
set updatetime=500

" Go to insert mode after/before 2 newlines
nmap 2o A<CR><CR>
nmap 2O I<CR><CR><Esc>kki

" correct joining of lines if comments
set formatoptions+=j

" Enable swap / backup / undo files for buffers
" and store them preferably separately from the edited file location
" ^= means prepend to the default directories list
" // means use the full file path as name (prevent name collisions)
set swapfile
set backup
set undofile
set directory^=~/.vim/swap//
set backupdir^=~/.vim/backup//
set undodir^=~/.vim/undo//
set viminfo+=n~/.vim/viminfo

" buffers bindings
nnoremap <silent> <Leader>ba :b#<CR>
nnoremap <silent> <Leader>bp :bprevious<CR>
nnoremap <silent> <Leader>bn :bnext<CR>
nnoremap <silent> <Leader>bc :vnew<CR>
nnoremap <silent> <Leader>bx :bdelete<CR>
nnoremap          <Leader>br :write<Space>

" manage alternate tab
let g:alternatetab = 1
autocmd TabLeave * let g:alternatetab = tabpagenr()
autocmd TabClosed * let g:alternatetab = 1

" tabs bindings
nnoremap <silent> <Leader>ta :execute "tabnext " . g:alternatetab<CR>
nnoremap <silent> <Leader>tp :tabprevious<CR>
nnoremap <silent> <Leader>tn :tabnext<CR>
nnoremap          <Leader>tc :TabooOpen tab
nnoremap <silent> <Leader>tx :tabclose<CR>
nnoremap          <Leader>tr :TabooRename<Space>

" Define special characters highlight display
set listchars=extends:>,tab:>\ ,trail:·
set list

" Strip trailing whitespaces except for certain filetypes
fun! s:FiletypeFilteredStripTrailingWhitespace()
  if &ft =~ 'markdown\|apiblueprint'
    return
  endif
  %s/\s\+$//e
endfun

" Strip all trailing whitespaces on saving based on filetype
autocmd BufWritePre * call <SID>FiletypeFilteredStripTrailingWhitespace()

" Toggle long lines highlighting
nnoremap <Leader>L :call<SID>LongLineHighlightToggle()<cr>

" Function to toggle highlighting of long lines
fun! s:LongLineHighlightToggle()
 if !exists('w:longlinehl')
  let w:longlinehl = matchadd('ErrorMsg', '.\%>80v', 0)
  echo "Long lines highlighted"
 else
  call matchdelete(w:longlinehl)
  unl w:longlinehl
  echo "Long lines unhighlighted"
 endif
endfunction

" Toggle window zoom
nnoremap <C-W>Z :call<SID>ZoomToggle()<cr>

" Function to toggle zoom of window
function! s:ZoomToggle()
  if exists('t:zoomed') && t:zoomed
    execute t:zoom_winrestcmd
    let t:zoomed = 0
  else
    let t:zoom_winrestcmd = winrestcmd()
    resize
    vertical resize
    let t:zoomed = 1
  endif
endfunction

" Load colorscheme first to handle color usage in plugins
source ~/.vim/conf/solarized.vim

" Load all the other conf files with their possible
" local extension/override immediately afterwards
let s:find_conf_cmd = "find ~/.vim/conf/ -name '*.vim'"
                \ . " ! -name solarized.vim ! -name '*.local.vim'"
let s:conf_files = glob("`" . s:find_conf_cmd . "`")
for conf in split(s:conf_files, '\n')
  exe 'source' conf

  let local_conf = substitute(conf, ".vim$", ".local.vim", "")
  if filereadable(local_conf)
    exe 'source' local_conf
  endif
endfor

" lighter vertical split display
set fillchars+=vert:│

" Mail config
autocmd BufRead,BufNewFile *mutt-* setfiletype mail
autocmd FileType mail setlocal formatoptions+=aw textwidth=72

" Tmux own filetype detection
autocmd BufNewFile,BufRead *.tmux set filetype=tmux

" Neomutt own filetype detection
autocmd BufNewFile,BufRead *.mutt set filetype=neomuttrc

" zsh functions own filetype detection
autocmd BufNewFile,BufRead *zsh/functions/* set filetype=zsh

" fzf config

nnoremap <silent> <Leader>ef :FZF<CR>

" extra bindings
let g:fzf_action = {
  \ 'ctrl-s': 'split',
  \ 'ctrl-v': 'vsplit' }

" same height as in terminal usage
let g:fzf_layout = { 'down': '20' }

" enable history
let g:fzf_history_dir = '~/.local/share/fzf-history'


" Search config

set ignorecase " ignore case when searching
set smartcase  " search sensitive if there is an uppercase in the search term
set incsearch  " highlight search results when typing
set hlsearch   " highlight search results
set nowrapscan " search stops at the end of file

" clear last search highlighting with Enter
nnoremap <silent> <CR> :noh<CR><Esc>

" initial search direction
let s:search_direction = 'down'

" move cursor on top/bottom of the page on new page
function! s:SearchFixPosition(reverse)
  if (s:search_direction == 'down' || (s:search_direction == 'up' && a:reverse))
    \ && line('.') > s:search_last_line
    normal! zt
  elseif (s:search_direction == 'up' || (s:search_direction == 'down' && a:reverse))
    \ && line('.') < s:search_first_line
    normal! zb
  endif
endfunction

" register current position
function! s:SearchRegisterPosition()
  let s:search_first_line = line('.') - winline() + 1
  let s:search_last_line = s:search_first_line + winheight(0) - 1
endfunction

" define search direction
function! s:SearchSetDirection(direction)
  let s:search_direction = a:direction
endfunction

" remap search related keys
nnoremap <silent> n :call <SID>SearchRegisterPosition()<CR>n
                    \:call <SID>SearchFixPosition(0)<CR>
nnoremap <silent> N :call <SID>SearchRegisterPosition()<CR>N
                    \:call <SID>SearchFixPosition(1)<CR>
nnoremap <silent> * :call <SID>SearchRegisterPosition()<CR>*
                    \:call <SID>SearchSetDirection('down')<CR>
                    \:call <SID>SearchFixPosition(0)<CR>
nnoremap <silent> # :call <SID>SearchRegisterPosition()<CR>#
                    \:call <SID>SearchSetDirection('up')<CR>
                    \:call <SID>SearchFixPosition(0)<CR>
nnoremap <silent> g* :call <SID>SearchRegisterPosition()<CR>g*
                     \:call <SID>SearchSetDirection('down')<CR>
                     \:call <SID>SearchFixPosition(0)<CR>
nnoremap <silent> g# :call <SID>SearchRegisterPosition()<CR>g#
                     \:call <SID>SearchSetDirection('up')<CR>
                     \:call <SID>SearchFixPosition(0)<CR>
nnoremap / :call <SID>SearchSetDirection('down')<CR>/
nnoremap ? :call <SID>SearchSetDirection('up')<CR>?
