" VIM Configuration
set nocompatible          " Cancel the compatibility with Vi

" Define the plugins
source ~/.vim/plugins.vim

" Disable arrow keys usage to break bad habits
noremap <Up> <nop>
noremap <Down> <nop>
noremap <Left> <nop>
noremap <Right> <nop>
noremap <PageUp> <nop>
noremap <PageDown> <nop>
noremap <Home> <nop>
noremap <End> <nop>

inoremap <Up> <nop>
inoremap <Down> <nop>
inoremap <Left> <nop>
inoremap <Right> <nop>
inoremap <PageUp> <nop>
inoremap <PageDown> <nop>
inoremap <Home> <nop>
inoremap <End> <nop>

vnoremap <Up> <nop>
vnoremap <Down> <nop>
vnoremap <Left> <nop>
vnoremap <Right> <nop>
vnoremap <PageUp> <nop>
vnoremap <PageDown> <nop>
vnoremap <Home> <nop>
vnoremap <End> <nop>

" Use space as leader
let mapleader = "\<Space>"

" Disable space moves cursor in non editing mode
noremap <Space> <nop>
vnoremap <Space> <nop>

" disable usage of Ctrl-J as Enter in command mode
cnoremap <C-J> <nop>

" remove ex mode binding
nmap Q <nop>

" Activate syntax coloring
syntax enable

" -- Display
set title                 " Update the title of your window or your terminal
set relativenumber        " Display relative line numbers
set ruler                 " Display cursor position
set wrap                  " Wrap lines when they are too long
set cursorline            " highlight the current line

set scrolloff=3           " Display at least 3 lines around you cursor
                          " (for scrolling)

" -- Beep
set visualbell            " Prevent Vim from beeping
set noerrorbells          " Prevent Vim from beeping

" Backspace behaves as expected
set backspace=indent,eol,start

" -- Tabs
set tabstop=4       " number of visual spaces per tab
set softtabstop=4   " number of spaces in tab when editing
set expandtab       " tabs are spaces when editing
set shiftwidth=4    " size of an indentation
set smarttab        " tab makes cursor goes to next indent when editing new line

" Visual autocomplete for command menu
set wildmenu

" Define files to ignore in globbing / expanding / ...
set wildignore+=*~,*.swp

" automatically reload file when modified outside of vim
" and not modified locally
set autoread

" Hide buffer (file) instead of abandoning when switching
" to another buffer
set hidden

" Activate specific behavior per file type such as syntax and indentation
filetype on
filetype plugin on
filetype indent on

" Decrease silent time before swap file gets written
set updatetime=500

" Go to insert mode after/before 2 newlines
nmap 2o A<CR><CR>
nmap 2O I<CR><CR><Esc>kki

" Enable swap / backup / undo files for buffers
" and store them preferably separately from the edited file location
" ^= means prepend to the default directories list
" // means use the full file path as name (prevent name collisions)
set swapfile
set backup
set undofile
set directory^=~/.vim/swap//
set backupdir^=~/.vim/backup//
set undodir^=~/.vim/undo//
set viminfo+=n~/.vim/viminfo

" switch to alternate/previous/next buffer
nnoremap <silent> <Leader>ba :b#<CR>
nnoremap <silent> <Leader>bp :bprevious<CR>
nnoremap <silent> <Leader>bn :bnext<CR>

" Toggle long lines highlighting
nnoremap <Leader>L :call<SID>LongLineHighlightToggle()<cr>

" Set long lines highlight background color
highlight OverLength ctermbg=1

" Detection of long lines (superior to 80 characters)
match OverLength /\%>80v/

" Function to toggle highlighting of long lines
fun! s:LongLineHighlightToggle()
 if !exists('w:longlinehl')
  let w:longlinehl = matchadd('ErrorMsg', '.\%>80v', 0)
  echo "Long lines highlighted"
 else
  call matchdelete(w:longlinehl)
  unl w:longlinehl
  echo "Long lines unhighlighted"
 endif
endfunction

" Toggle window zoom
nnoremap <C-W>Z :call<SID>ZoomToggle()<cr>

" Function to toggle zoom of window
function! s:ZoomToggle()
  if exists('t:zoomed') && t:zoomed
    execute t:zoom_winrestcmd
    let t:zoomed = 0
  else
    let t:zoom_winrestcmd = winrestcmd()
    resize
    vertical resize
    let t:zoomed = 1
  endif
endfunction

" Load colorscheme first to handle color usage in plugins
source ~/.vim/conf/solarized.vim

" Load all the other conf files with their possible
" local extension/override immediately afterwards
let s:find_conf_cmd = "find ~/.vim/conf/ -name '*.vim'"
                \ . " ! -name solarized.vim ! -name '*.local.vim'"
let s:conf_files = glob("`" . s:find_conf_cmd . "`")
for conf in split(s:conf_files, '\n')
  exe 'source' conf

  let local_conf = substitute(conf, ".vim$", ".local.vim", "")
  if filereadable(local_conf)
    exe 'source' local_conf
  endif
endfor

" "hide" end of buffer sign
" the line numbers are already marking the end of the buffer
highlight EndOfBuffer ctermfg=bg

" lighter vertical split display
set fillchars+=vert:â”‚
highlight VertSplit ctermbg=NONE

" Mail config
autocmd BufRead,BufNewFile *mutt-* setfiletype mail
autocmd FileType mail setlocal formatoptions+=aw textwidth=72

" Search config

set ignorecase " ignore case when searching
set smartcase  " search sensitive if there is an uppercase in the search term
set incsearch  " highlight search results when typing
set hlsearch   " highlight search results
set nowrapscan " search stops at the end of file

" clear last search highlighting with Enter
nnoremap <silent> <CR> :noh<CR><Esc>

" initial search direction
let s:search_direction = 'down'

" move cursor on top/bottom of the page on new page
function s:SearchFixPosition(reverse)
  if (s:search_direction == 'down' || (s:search_direction == 'up' && a:reverse))
    \ && winline() == winheight(0) - &scrolloff
    normal! zt
  elseif (s:search_direction == 'up' || (s:search_direction == 'down' && a:reverse))
    \ && winline() == &scrolloff + 1
    normal! zb
  endif
endfunction

" define search direction
function s:SetSearchDirection(direction)
  let s:search_direction = a:direction
endfunction

" remap search related keys
nnoremap <silent> n n:call <SID>SearchFixPosition(0)<CR>
nnoremap <silent> N N:call <SID>SearchFixPosition(1)<CR>
nnoremap <silent> * *:call <SID>SetSearchDirection('down')<CR>:call <SID>SearchFixPosition(0)<CR>
nnoremap <silent> # #:call <SID>SetSearchDirection('up')<CR>:call <SID>SearchFixPosition(0)<CR>
nnoremap <silent> g* g*:call <SID>SetSearchDirection('down')<CR>:call <SID>SearchFixPosition(0)<CR>
nnoremap <silent> g# g#:call <SID>SetSearchDirection('up')<CR>:call <SID>SearchFixPosition(0)<CR>
nnoremap / :call <SID>SetSearchDirection('down')<CR>/
nnoremap ? :call <SID>SetSearchDirection('up')<CR>?
