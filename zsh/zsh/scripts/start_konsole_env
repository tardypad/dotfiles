#!/usr/bin/env zsh

COMMAND=${0:t}
ENV_DIR_PATH=${0:A:h}/konsole_env

init_variables() {
  AVAILABLE_TARGETS=( $(
    ls "${ENV_DIR_PATH}" | sed -r 's/(.*).sh/\1/'
  ) )

  TARGET=
}


usage() {
  cat << EOF
usage: ${COMMAND} [<options>] [<target>]

Start target konsole environment
Each target is a different tab of the main konsole window

Options:
  -h,  --help     show this message only

Available targets: ${AVAILABLE_TARGETS}
If target is not defined, all of them are started
EOF
}


error() {
  if [[ -n "$1" ]]; then
    echo "error: $1" >&2
  fi
  usage
  exit 1
}


get_konsole() {
  local -a current_services

  # look for current konsole env
  for service in $( qdbus 'org.kde.konsole*' ); do
    local app_name=$(
      qdbus "${service}" /MainApplication org.qtproject.Qt.QCoreApplication.applicationName
    )

    if [[ "${app_name}" == 'konsole_env' ]]; then
        # konsole env is found
        echo "${service}" 0
        return
    fi

    current_services+=( "${service}" )
  done

  # if no konsole env, start one in a separate service
  konsole --separate --profile Shell &> /dev/null

  # use the service of the new konsole
  local qdbus_service
  for service in $( qdbus 'org.kde.konsole*' ); do
    if ! (( ${current_services[(Ie)${service}]} )); then
      qdbus_service="${service}"
      break
    fi
  done

  # global environment setup
  qdbus "${qdbus_service}" /MainApplication org.qtproject.Qt.QCoreApplication.applicationName 'konsole_env' &> /dev/null
  qdbus "${qdbus_service}" /konsole/MainWindow_1 org.qtproject.Qt.QWidget.showFullScreen &> /dev/null
  qdbus "${qdbus_service}" /konsole/MainWindow_1 org.qtproject.Qt.QWidget.windowOpacity 0.8 &> /dev/null

  echo "${qdbus_service}" 1
}


get_sessions_title() {
  local qdbus_service="$1"

  local sessions_number=( $(
    qdbus "${qdbus_service}" \
      | grep '/Sessions/' \
      | sed -r 's/\/Sessions\/([0-9]+)/\1/'
  ) )

  for i in $sessions_number; do
     qdbus "${qdbus_service}" "/Sessions/$i" org.kde.konsole.Session.title 1
  done
}


get_session_pattern() {
  local script_path="$1"

  local session_name="${script_path:t:r}"

  # there seems to be no way currently to check session name case insensitively
  # so we create a pattern manually for it
  local session_pattern='*'
  for i in $( seq 0 $(( ${#session_name} - 1 )) ); do
    local char="${session_name:$i:1}"
    local char_low=$( echo "${char}" | tr 'A-Z' 'a-z' )
    local char_up=$( echo "${char}" | tr 'a-z' 'A-Z' )
    session_pattern+="[${char_low}${char_up}]"
  done
  session_pattern+='*'

  echo "${session_pattern}"
}



start_target_konsole_env() {
  local qdbus_service="$1"
  local is_new="$2"

  # activate window
  if command -v xdotool &> /dev/null; then
    local window_id=$(
      qdbus "${qdbus_service}" /konsole/MainWindow_1 org.kde.KMainWindow.winId
    )
    xdotool windowactivate "${window_id}" &> /dev/null
  fi

  # get current sessions title
  local -a sessions_title
  if [[ "${is_new}" -eq 0 ]]; then
    sessions_title=( $(
      get_sessions_title "${qdbus_service}"
    ) )
  fi

  # get scripts path to run
  local scripts_path
  if [[ -n "${TARGET}" ]]; then
    scripts_path=(
      "${ENV_DIR_PATH}/${TARGET}.sh"
    )
  else
    scripts_path=( $(
      ls "${ENV_DIR_PATH}"/*.sh
    ) )
  fi

  local session
  for script_path in ${scripts_path}; do
    if [[ "${is_new}" -eq 1 ]]; then
      # use the session created with the window
      session=$(
        qdbus "${qdbus_service}" /Windows/1 org.kde.konsole.Window.currentSession
      )
      is_new=0
    else
      local session_pattern=$( get_session_pattern "${script_path}" )
      if (( ${sessions_title[(I)${session_pattern}]} )); then
        # target session is already present
        continue;
      else
        # create new session
        session=$(
          qdbus "${qdbus_service}" /Windows/1 org.kde.konsole.Window.newSession
        )
      fi
    fi

    bash "${script_path}" "${qdbus_service}" "${session}"
  done
}


parse_options() {
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      -h|--help)
        usage
        exit 0
        ;;
      *)
        break 2
        ;;
    esac
  done

  TARGET="$1"
}


validate_options() {
  # validate target if present
  if [[ -n "${TARGET}" ]] \
      && ! (( ${AVAILABLE_TARGETS[(Ie)${TARGET}]} )); then
    error "invalid target ${TARGET}"
  fi
}

init_variables
parse_options "$@"
validate_options

start_target_konsole_env $( get_konsole )
